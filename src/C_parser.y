%code requires{
  #include "ast.hpp"

  #include <cassert>

  extern const Expression *g_root; // A way of getting the AST out

  //! This is to fix problems when generating C++
  // We are declaring the functions provided by Flex, so
  // that Bison generated code can call them.
  int yylex(void);
  void yyerror(const char *);
}

// Represents the value associated with any kind of
// AST node.
%union{
  const Expression *expr;
  double number;
  std::string *string;
}

%define parse.error verbose

%token T_VARIABLE T_INTEGER T_STRING T_TYPEDEF

%token T_INC_OP T_DEC_OP T_LEFT_OP T_RIGHT_OP T_LE_OP T_GE_OP T_GT T_LT T_EQUALTO T_NOT_EQUALTO

%token T_TIMES T_PLUS T_MINUS T_DIVIDE T_NOT T_XOR_OP T_TILDA 

%token T_COMMA T_SEMICOLON T_LBRACKET T_RBRACKET T_ASS T_LCBRACKET T_RCBRACKET T_LSBRACKET T_RSBRACKET T_COLON

%token T_AND_OP T_OR_OP T_LOGICAL_AND_OP T_LOGICAL_OR_OP MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN ADD_ASSIGN

%token SUB_ASSIGN LEFT_ASSIGN RIGHT_ASSIGN AND_ASSIGN

%token XOR_ASSIGN OR_ASSIGN T_MOD

%token T_CHAR T_INT T_UNSIGNED T_FLOAT T_DOUBLE T_VOID

%token STRUCT T_ENUM

%token T_CASE T_DEFAULT T_IF T_ELSE T_SWITCH T_WHILE DO T_CONTINUE T_BREAK T_RETURN T_FOR

%type <expr> EXPR DECLARATION CONDITIONAL STATEMENT STATEMENT_LIST COMPOUND_STATEMENT UNARY_EXPRESSION JUMP PRIMARY_EXPRESSION ARGUMENT_EXP_LIST CAST_EXPRESSION

%type <expr> MULTIPLICATIVE_EXPRESSION ADDITIVE_EXPRESSION SHIFT_EXPRESSION RELATIONAL_EXPRESSION EQUALITY_EXPRESSION AND_EXPRESSION EXCLUSIVE_OR_EXPRESSION

%type <expr> DECLARATOR DECLARATION_LIST EXTERNAL_DECLARATION BITWISE_OR_EXPRESSION LOGICAL_AND_EXPRESSION LOGICAL_OR_EXPRESSION

%type <expr> FUNCTION_DEFINITION EXPRESSION_STATEMENT ITERATION_STATEMENT INIT_DECLARATOR INITIALISER INITIALISER_LIST STRUCT_SPECIFIER ENUM_SPECIFIER INIT_DECLARATOR_LIST

%type <expr> TYPE_SPECIFIER PARAMETER_LIST STRUCT_DECLARATION_LIST STRUCT_DECLARATOR SPECIFIER_QUALIFIER_LIST IDENTIFIER_LIST DIRECT_DECLARATOR ENUMERATOR_LIST

%type <expr> DECLARATION_SPECIFIERS LABELED_STATEMENT STRUCT_DECLARATION POINTER STRUCT_DECLARATOR_LIST PARAMETER_DECLARATION ENUMERATOR ASSIGNMENT_EXPRESSION TRANSLATION_UNIT POSTFIX_EXPRESSION

%type <number> T_INTEGER

%type <string> T_DEFAULT T_CASE T_SWITCH T_INC_OP T_DEC_OP T_VARIABLE T_DOUBLE T_FLOAT T_INT T_UNSIGNED T_CHAR T_IF T_ELSE T_WHILE T_RETURN UNARY T_VOID T_TYPEDEF T_PLUS T_MINUS T_NOT T_TILDA T_AND_OP T_TIMES T_ASS SUB_ASSIGN LEFT_ASSIGN RIGHT_ASSIGN AND_ASSIGN T_MOD T_BREAK

%type <string> T_CONTINUE T_LOGICAL_AND_OP T_LOGICAL_OR_OP T_LE_OP T_GE_OP T_GT T_LT T_EQUALTO T_NOT_EQUALTO ASSIGNMENT_OPERATOR   MUL_ASSIGN DIV_ASSIGN XOR_ASSIGN OR_ASSIGN ADD_ASSIGN MOD_ASSIGN


%start ROOT
%%

ROOT : TRANSLATION_UNIT {g_root = $1;}

PRIMARY_EXPRESSION
	: T_VARIABLE { $$ = new Variable(*$1);}
	| T_INTEGER { $$ = new Number($1);}
	| T_LBRACKET EXPR T_RBRACKET { $$ = $2;}
	;

POSTFIX_EXPRESSION
	: PRIMARY_EXPRESSION { $$ = $1;}
	| POSTFIX_EXPRESSION T_LSBRACKET EXPR T_RSBRACKET { $$ = new ArrayAccess($1, $3); }
	| POSTFIX_EXPRESSION T_LBRACKET T_RBRACKET { $$ = new PostfixExpression($1, NULL);}
	| POSTFIX_EXPRESSION T_LBRACKET ARGUMENT_EXP_LIST T_RBRACKET { $$ = new PostfixExpression($1, $3);}
	| POSTFIX_EXPRESSION '.' T_VARIABLE {}
	| POSTFIX_EXPRESSION T_INC_OP { $$ = new IncOperator($1, *$2); }
	| POSTFIX_EXPRESSION T_DEC_OP { $$ = new IncOperator($1, *$2); }
	;

ARGUMENT_EXP_LIST
	: ASSIGNMENT_EXPRESSION { $$ = new ArguementList(NULL, $1); }
	| ARGUMENT_EXP_LIST T_COMMA ASSIGNMENT_EXPRESSION { $$ = new ArguementList($1, $3);}
	;

UNARY_EXPRESSION
	: POSTFIX_EXPRESSION { $$ = $1;}
	| T_INC_OP UNARY_EXPRESSION {$$ = new PreIncOperator(*$1, $2);}
	| T_DEC_OP UNARY_EXPRESSION {$$ = new PreIncOperator(*$1, $2);}
	| UNARY CAST_EXPRESSION { $$ = new UnaryOperator(*$1, $2);}
	;

UNARY
	: T_AND_OP { $$ = new std::string(*$1);}
	| T_TIMES { $$ = new std::string(*$1);}
	| T_PLUS { $$ = new std::string(*$1);;}
	| T_MINUS { $$ = new std::string(*$1);}
	| T_NOT { $$ = new std::string(*$1);}
	| T_TILDA { $$ = new std::string(*$1);}
	;

CAST_EXPRESSION
	: UNARY_EXPRESSION { $$ = $1;}
	| T_LBRACKET SPECIFIER_QUALIFIER_LIST T_RBRACKET CAST_EXPRESSION { }
	;

MULTIPLICATIVE_EXPRESSION
	: CAST_EXPRESSION { $$ = $1;}
	| MULTIPLICATIVE_EXPRESSION T_TIMES CAST_EXPRESSION { $$ = new MulOperator($1, $3);}
	| MULTIPLICATIVE_EXPRESSION T_DIVIDE CAST_EXPRESSION { $$ = new DivOperator($1, $3);}
	| MULTIPLICATIVE_EXPRESSION T_MOD CAST_EXPRESSION { $$ = new ModOperator($1, $3);}
	;

ADDITIVE_EXPRESSION
	: MULTIPLICATIVE_EXPRESSION { $$ = $1;}
	| ADDITIVE_EXPRESSION T_PLUS MULTIPLICATIVE_EXPRESSION { $$ = new AddOperator($1, $3);}
	| ADDITIVE_EXPRESSION T_MINUS MULTIPLICATIVE_EXPRESSION { $$ = new SubOperator($1, $3);}
	;

SHIFT_EXPRESSION
	: ADDITIVE_EXPRESSION { $$ = $1;}
	| SHIFT_EXPRESSION T_LEFT_OP ADDITIVE_EXPRESSION { $$ = new LeftShiftOperator($1,$3);}
	| SHIFT_EXPRESSION T_RIGHT_OP ADDITIVE_EXPRESSION {$$ = new RightShiftOperator($1,$3); }
	;

RELATIONAL_EXPRESSION
	: SHIFT_EXPRESSION { $$ = $1;}
	| RELATIONAL_EXPRESSION T_LT SHIFT_EXPRESSION { $$ = new LessThanOperator($1, $3);}
	| RELATIONAL_EXPRESSION T_GT SHIFT_EXPRESSION { $$ = new GreaterThanOperator($1, $3);}
	| RELATIONAL_EXPRESSION T_LE_OP SHIFT_EXPRESSION { $$ = new LessThanEquOperator($1, $3);}
	| RELATIONAL_EXPRESSION T_GE_OP SHIFT_EXPRESSION { $$ = new GreaterThanEquOperator($1, $3);}
	;

EQUALITY_EXPRESSION
	: RELATIONAL_EXPRESSION { $$ = $1;}
	| EQUALITY_EXPRESSION T_EQUALTO RELATIONAL_EXPRESSION { $$ = new EqualityOperator($1, $3);}
	| EQUALITY_EXPRESSION T_NOT_EQUALTO RELATIONAL_EXPRESSION { $$ = new InEqualityOperator($1, $3);}
	;

AND_EXPRESSION
	: EQUALITY_EXPRESSION { $$ = $1;}
	| AND_EXPRESSION T_AND_OP EQUALITY_EXPRESSION { $$ = new BitAndOperator($1, $3);}
	;

EXCLUSIVE_OR_EXPRESSION
	: AND_EXPRESSION { $$ = $1;}
	| EXCLUSIVE_OR_EXPRESSION T_XOR_OP AND_EXPRESSION { $$ = new XOROperator($1, $3);}
	;

BITWISE_OR_EXPRESSION
	: EXCLUSIVE_OR_EXPRESSION { $$ = $1;}
	| BITWISE_OR_EXPRESSION T_OR_OP EXCLUSIVE_OR_EXPRESSION { $$ = new BitOrOperator($1, $3);}
	;

LOGICAL_AND_EXPRESSION
	: BITWISE_OR_EXPRESSION { $$ = $1;}
	| LOGICAL_AND_EXPRESSION T_LOGICAL_AND_OP BITWISE_OR_EXPRESSION { $$ = new AndOperator($1, $3);}
	;

LOGICAL_OR_EXPRESSION
	: LOGICAL_AND_EXPRESSION { $$ = $1;}
	| LOGICAL_OR_EXPRESSION T_LOGICAL_OR_OP LOGICAL_AND_EXPRESSION { $$ = new OrOperator($1, $3);}
	;

ASSIGNMENT_EXPRESSION
	: LOGICAL_OR_EXPRESSION { $$ = $1;}
	| UNARY_EXPRESSION ASSIGNMENT_OPERATOR ASSIGNMENT_EXPRESSION { $$ = new AssignmentOperator($1, *$2, $3);}
	;

ASSIGNMENT_OPERATOR
	: T_ASS { $$ = new std::string(*$1);}
	| MUL_ASSIGN { $$ = new std::string(*$1);}
	| DIV_ASSIGN { $$ = new std::string(*$1);}
	| MOD_ASSIGN { $$ = new std::string(*$1);}
	| ADD_ASSIGN { $$ = new std::string(*$1);}
	| SUB_ASSIGN { $$ = new std::string(*$1);}
	| LEFT_ASSIGN { $$ = new std::string(*$1);}
	| RIGHT_ASSIGN { $$ = new std::string(*$1);}
	| AND_ASSIGN { $$ = new std::string(*$1);}
	| XOR_ASSIGN { $$ = new std::string(*$1);}
	| OR_ASSIGN { $$ = new std::string(*$1);}
	;

EXPR
	: ASSIGNMENT_EXPRESSION { $$ = $1; }
	| EXPR T_COMMA ASSIGNMENT_EXPRESSION { }
	;

DECLARATION
	: DECLARATION_SPECIFIERS T_SEMICOLON { }
	| DECLARATION_SPECIFIERS INIT_DECLARATOR_LIST T_SEMICOLON { $$ = new Declaration($2); }
	;

DECLARATION_SPECIFIERS
	: T_TYPEDEF { }
	| T_TYPEDEF DECLARATION_SPECIFIERS {}
	| TYPE_SPECIFIER { $$ = $1; }
	| TYPE_SPECIFIER DECLARATION_SPECIFIERS {}
	;

INIT_DECLARATOR_LIST
	: INIT_DECLARATOR { $$ = $1; }
	| INIT_DECLARATOR_LIST T_COMMA INIT_DECLARATOR { $$ = new DeclaratorList($1, $3); }
	;

INIT_DECLARATOR
	: DECLARATOR { $$ = new AssDeclaration($1, NULL); }
	| DECLARATOR T_ASS INITIALISER { $$ = new AssDeclaration($1, $3); }
	;

TYPE_SPECIFIER
	: T_VOID { }
	| T_CHAR { }
	| T_INT { }
	| T_FLOAT { }
	| T_DOUBLE { }
	| T_UNSIGNED { }
	| STRUCT_SPECIFIER  { }
	| ENUM_SPECIFIER { $$ = $1; }
	;

STRUCT_SPECIFIER
	: STRUCT T_VARIABLE T_LCBRACKET STRUCT_DECLARATION_LIST T_RCBRACKET { }
	| STRUCT T_LCBRACKET STRUCT_DECLARATION_LIST T_RCBRACKET { }
	| STRUCT T_VARIABLE { }
	;

STRUCT_DECLARATION_LIST
	: STRUCT_DECLARATION { }
	| STRUCT_DECLARATION_LIST STRUCT_DECLARATION { }
	;

STRUCT_DECLARATION
	: SPECIFIER_QUALIFIER_LIST STRUCT_DECLARATOR_LIST T_SEMICOLON { }
	;

SPECIFIER_QUALIFIER_LIST
	: TYPE_SPECIFIER SPECIFIER_QUALIFIER_LIST { }
	| TYPE_SPECIFIER { }
	;

STRUCT_DECLARATOR_LIST
	: STRUCT_DECLARATOR { }
	| STRUCT_DECLARATOR_LIST T_COMMA STRUCT_DECLARATOR { }
	;

STRUCT_DECLARATOR
	: DECLARATOR { }
	| T_COLON LOGICAL_OR_EXPRESSION { }
	| DECLARATOR T_COLON LOGICAL_OR_EXPRESSION { }
	;

ENUM_SPECIFIER
	: T_ENUM T_LCBRACKET ENUMERATOR_LIST T_RCBRACKET { }
	| T_ENUM T_VARIABLE T_LCBRACKET ENUMERATOR_LIST T_RCBRACKET { $$ = new Enum($4); }
	| T_ENUM T_VARIABLE { }
	;

ENUMERATOR_LIST
	: ENUMERATOR {$$ = $1; }
	| ENUMERATOR_LIST T_COMMA ENUMERATOR {$$ = new EnumList($1, $3); }
	;

ENUMERATOR
	: T_VARIABLE { $$ = new EnumAss(*$1, NULL);}
	| T_VARIABLE T_ASS LOGICAL_OR_EXPRESSION { $$ = new EnumAss(*$1, $3); }
	;

DECLARATOR
	: POINTER DIRECT_DECLARATOR { }
	| DIRECT_DECLARATOR { $$ = $1;}
	;

DIRECT_DECLARATOR
	: T_VARIABLE { $$ = new Variable(*$1); }
	| T_LBRACKET DECLARATOR T_RBRACKET { }
	| DIRECT_DECLARATOR T_LSBRACKET LOGICAL_OR_EXPRESSION T_RSBRACKET { $$ = new Array($1, $3); }
	| DIRECT_DECLARATOR T_LSBRACKET T_RSBRACKET { }
	| DIRECT_DECLARATOR T_LBRACKET PARAMETER_LIST T_RBRACKET { $$ = new FunctionParamDec($1, $3); }
	| DIRECT_DECLARATOR T_LBRACKET IDENTIFIER_LIST T_RBRACKET { }
	| DIRECT_DECLARATOR T_LBRACKET T_RBRACKET { $$ = new FunctionParamDec($1, NULL); }
	;

POINTER
	: T_TIMES { }
	| T_TIMES POINTER {  }
	;

PARAMETER_LIST
	: PARAMETER_DECLARATION { $$ = $1;}
	| PARAMETER_LIST T_COMMA PARAMETER_DECLARATION { $$ = new ParamList($1, $3);}
	;

PARAMETER_DECLARATION
	: DECLARATION_SPECIFIERS DECLARATOR { $$ = new ParamDeclaration($2);}
	| DECLARATION_SPECIFIERS { }
	;

IDENTIFIER_LIST
	: T_VARIABLE { $$ = new Variable(*$1);}
	| IDENTIFIER_LIST T_COMMA T_VARIABLE { }
	;

INITIALISER
	: ASSIGNMENT_EXPRESSION { $$ = $1;}
	| T_LCBRACKET INITIALISER_LIST T_RCBRACKET { }
	| T_LCBRACKET INITIALISER_LIST T_COMMA T_RCBRACKET { }
	;

INITIALISER_LIST
	: INITIALISER { }
	| INITIALISER_LIST T_COMMA INITIALISER { }
	;

STATEMENT
	: LABELED_STATEMENT { }
	| COMPOUND_STATEMENT { $$ = $1;}
	| EXPRESSION_STATEMENT { $$ = $1;}
	| CONDITIONAL { $$ = $1;}
	| ITERATION_STATEMENT { $$ = $1;}
	| JUMP { $$ = $1;}
	;

LABELED_STATEMENT
	: T_VARIABLE T_COLON STATEMENT {  }
	| T_CASE LOGICAL_OR_EXPRESSION T_COLON STATEMENT { $$ = new CaseStatement($2, $4); }
	| T_DEFAULT T_COLON STATEMENT { $$ = new DefaultStatement($3); }
	;

COMPOUND_STATEMENT
	: T_LCBRACKET T_RCBRACKET {  $$ = NULL; }
	| T_LCBRACKET STATEMENT_LIST T_RCBRACKET {  $$ = $2; }
	| T_LCBRACKET DECLARATION_LIST T_RCBRACKET {  $$ = $2; }
	| T_LCBRACKET DECLARATION_LIST STATEMENT_LIST T_RCBRACKET {  $$ = new CompoundStatement($2, $3); }
	;

DECLARATION_LIST
	: DECLARATION {  $$ = $1; }
	| DECLARATION_LIST DECLARATION {  $$ = new DeclarationList($1, $2); }
	;

STATEMENT_LIST
	: STATEMENT {  $$ = $1; }
	| STATEMENT_LIST STATEMENT {  $$ = new StatementList($1, $2); }
	;

EXPRESSION_STATEMENT
	: T_SEMICOLON {  }
	| EXPR T_SEMICOLON {  $$ = new Statement($1); }
	;

CONDITIONAL
	: T_IF T_LBRACKET EXPR T_RBRACKET STATEMENT {  $$ = new IfStatement($3, $5); }
	| T_IF T_LBRACKET EXPR T_RBRACKET STATEMENT T_ELSE STATEMENT {  $$ = new IfElseStatement($3, $5, $7); }
	| T_SWITCH T_LBRACKET EXPR T_RBRACKET STATEMENT {  $$ = new SwitchStatement($3, $5); }
	;

ITERATION_STATEMENT
	: T_WHILE T_LBRACKET EXPR T_RBRACKET STATEMENT {  $$ = new WhileStatement($3, $5); }
	| DO STATEMENT T_WHILE T_LBRACKET EXPR T_RBRACKET T_SEMICOLON {  }
	| T_FOR T_LBRACKET EXPRESSION_STATEMENT EXPRESSION_STATEMENT T_RBRACKET STATEMENT { $$ = new ForStatement(NULL, $3, $4, $6); }
	| T_FOR T_LBRACKET EXPRESSION_STATEMENT EXPRESSION_STATEMENT EXPR T_RBRACKET STATEMENT { $$ = new ForStatement($3, $4, $5, $7); }
	;

JUMP
	: T_CONTINUE T_SEMICOLON {  $$ = new ContinueStatement(); }
	| T_BREAK T_SEMICOLON {  $$ = new BreakStatement(); }
	| T_RETURN T_SEMICOLON {  $$ = new ReturnStatement(NULL); }
	| T_RETURN EXPR T_SEMICOLON {  $$ = new ReturnStatement($2); }
	;

TRANSLATION_UNIT
	: EXTERNAL_DECLARATION {  $$ = $1; }
	| TRANSLATION_UNIT EXTERNAL_DECLARATION {  $$ = new TranslationUnit($1,$2); }
	;

EXTERNAL_DECLARATION
	: FUNCTION_DEFINITION {  $$ = $1; }
	| DECLARATION { $$ = new GlobalDec($1); }
	;

FUNCTION_DEFINITION
	: DECLARATION_SPECIFIERS DECLARATOR DECLARATION_LIST COMPOUND_STATEMENT {  }
	| DECLARATION_SPECIFIERS DECLARATOR COMPOUND_STATEMENT {  $$ = new FunctionDec($2, $3);}
	| DECLARATOR DECLARATION_LIST COMPOUND_STATEMENT {  }
	| DECLARATOR COMPOUND_STATEMENT {  }
	;

%%

const Expression *g_root; // Definition of variable (to match declaration earlier)

const Expression *parseAST_cin()
{
  g_root=0;
  yyparse();
  return g_root;
}

// const Expression *parseAST_file(std::string in_file)
// {
//   g_root=0;
//   yyin = fopen(in_file, "r");
//   if(yyin){
// 	yyparse();
//   }
//   fclose(yyin);
//   return g_root;
// }
